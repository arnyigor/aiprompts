# ==============================================================================
# GitHub Workflow: –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ "–∂–∏–≤–æ–≥–æ" –∞—Ä—Ö–∏–≤–∞ —Å –ø—Ä–æ–º–ø—Ç–∞–º–∏
# ==============================================================================
# –≠—Ç–æ—Ç –≤–æ—Ä–∫—Ñ–ª–æ—É —Å–ª–µ–¥–∏—Ç –∑–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º–∏ –≤ –ø–∞–ø–∫–µ `prompts` –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
# –æ–±–Ω–æ–≤–ª—è–µ—Ç –æ–¥–∏–Ω-–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π "–∂–∏–≤–æ–π" —Ä–µ–ª–∏–∑ —Å —Ç–µ–≥–æ–º `latest-prompts`.
#
# –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –æ–±—Ä–∞—â–∞–µ—Ç—Å—è –∫ —ç—Ç–æ–º—É —Ä–µ–ª–∏–∑—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∞–º–æ–π —Å–≤–µ–∂–µ–π
# –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –ø—Ä–æ–º–ø—Ç–æ–≤.
#
# --- –¢–†–ò–ì–ì–ï–†–´ –ó–ê–ü–£–°–ö–ê ---
# 1. –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò: –ø—Ä–∏ –ø—É—à–µ –≤ –æ—Å–Ω–æ–≤–Ω—É—é –≤–µ—Ç–∫—É, –µ—Å–ª–∏ –±—ã–ª–∏ –∏–∑–º–µ–Ω–µ–Ω—ã —Ñ–∞–π–ª—ã
#    –≤–Ω—É—Ç—Ä–∏ –ø–∞–ø–∫–∏ `prompts/`.
# 2. –í–†–£–ß–ù–£–Æ: —á–µ—Ä–µ–∑ –≤–∫–ª–∞–¥–∫—É "Actions" –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏ GitHub.
# ==============================================================================

name: Update Prompts Library

on:
  # 1. –ó–∞–ø—É—Å–∫–∞—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ –ª—é–±–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –≤ –ø–∞–ø–∫–µ prompts
  push:
    branches:
      - main # –£–∫–∞–∂–∏—Ç–µ –∑–¥–µ—Å—å –≤–∞—à—É –æ—Å–Ω–æ–≤–Ω—É—é –≤–µ—Ç–∫—É (main –∏–ª–∏ master)
    paths:
      - 'prompts/**'

  # 2. –ü–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–ø—É—Å–∫–∞—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä—É—á–Ω—É—é
  workflow_dispatch:

# --- –í–ê–ñ–ù–û: –ü–†–ï–î–û–°–¢–ê–í–õ–ï–ù–ò–ï –ü–†–ê–í ---
# –Ø–≤–Ω–æ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ –∑–∞–ø–∏—Å—å –≤ "contents" —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è.
# –≠—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è/–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–µ–ª–∏–∑–æ–≤ –∏ –∑–∞–≥—Ä—É–∑–∫–∏ –∞—Å—Å–µ—Ç–æ–≤.
# –ë–µ–∑ —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞ –±—É–¥–µ—Ç –æ—à–∏–±–∫–∞ 403 Forbidden.
permissions:
  contents: write

jobs:
  update_prompts_archive:
    name: Package and Update Prompts Archive
    runs-on: ubuntu-latest

    steps:
      # –®–∞–≥ 1: –ü–æ–ª—É—á–∞–µ–º –∫–æ–¥ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
      - name: Checkout code
        uses: actions/checkout@v3

      # –®–∞–≥ 2: –°–æ–∑–¥–∞–µ–º zip-–∞—Ä—Ö–∏–≤ —Å –ø–∞–ø–∫–æ–π prompts
      - name: Archive prompts directory
        run: zip -r prompts.zip ./prompts

      # –®–∞–≥ 3: –û–±–Ω–æ–≤–ª—è–µ–º –∞—Å—Å–µ—Ç –≤ "–∂–∏–≤–æ–º" —Ä–µ–ª–∏–∑–µ
      # Action `softprops/action-gh-release` —Å–∞–º –Ω–∞–π–¥–µ—Ç —Ä–µ–ª–∏–∑ –ø–æ —Ç–µ–≥—É,
      # —Å–æ–∑–¥–∞—Å—Ç –µ–≥–æ, –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –∏ –ø–µ—Ä–µ–∑–∞–ø–∏—à–µ—Ç –∞—Å—Å–µ—Ç—ã —Å
      # —Ç–µ–º –∂–µ –∏–º–µ–Ω–µ–º.
      - name: Update or Create Release with Prompts Asset
        uses: softprops/action-gh-release@v1
        with:
          tag_name: latest-prompts # –°—Ç–∞–±–∏–ª—å–Ω—ã–π —Ç–µ–≥, –∫–æ—Ç–æ—Ä—ã–π –º—ã –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
          name: "Prompts Library (Latest)"
          body: "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ–º–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –ø—Ä–æ–º–ø—Ç–æ–≤. –≠—Ç–æ—Ç —Ä–µ–ª–∏–∑ –≤—Å–µ–≥–¥–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–∞–º—É—é —Å–≤–µ–∂—É—é –≤–µ—Ä—Å–∏—é."
          draft: false
          prerelease: false
          files: prompts.zip # Action –Ω–∞–π–¥–µ—Ç –∏ –ø–µ—Ä–µ–∑–∞–ø–∏—à–µ—Ç —ç—Ç–æ—Ç —Ñ–∞–π–ª, –µ—Å–ª–∏ –æ–Ω —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø –° –ë–ê–ó–û–ô –î–ê–ù–ù–´–•
      - name: Sync to Database with Full Diagnostics
        run: |
          echo "üîÑ Starting sync with diagnostics at $(date)"
          
          # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
          CHUNK_SIZE=10  # –£–º–µ–Ω—å—à–∞–µ–º —Ä–∞–∑–º–µ—Ä —á–∞–Ω–∫–∞
          MAX_RETRIES=2
          RETRY_DELAY=3
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
          echo "üîç Environment check:"
          if [ -z "${{ secrets.SYNC_WEBHOOK_URL }}" ]; then
              echo "‚ùå SYNC_WEBHOOK_URL is not set"
              exit 1
          else
              echo "‚úÖ SYNC_WEBHOOK_URL is configured"
              # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–æ–º–µ–Ω –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
              echo "   URL domain: $(echo '${{ secrets.SYNC_WEBHOOK_URL }}' | cut -d'/' -f1-3)"
          fi
          
          if [ -z "${{ secrets.SYNC_API_KEY }}" ]; then
              echo "‚ùå SYNC_API_KEY is not set"
              exit 1
          else
              echo "‚úÖ SYNC_API_KEY is configured (length: ${#{{ secrets.SYNC_API_KEY }}})"
          fi
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ñ–∞–π–ª–æ–≤
          JSON_FILES=$(find prompts -name "*.json" | wc -l)
          if [ "$JSON_FILES" -eq 0 ]; then
              echo "‚ö†Ô∏è No JSON files found - skipping sync"
              exit 0
          fi
          
          echo "üìä Found $JSON_FILES JSON files, processing in chunks of $CHUNK_SIZE"
          
          # –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –∏ —Ä–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —á–∞–Ω–∫–∏
          find prompts -name "*.json" > files_list.txt
          split -l $CHUNK_SIZE files_list.txt chunk_
          
          # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–π —á–∞–Ω–∫ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
          chunk_file="chunk_aa"
          if [ ! -f "$chunk_file" ]; then
              echo "‚ùå First chunk file not found"
              exit 1
          fi
          
          echo "üî¨ DIAGNOSTIC MODE: Processing only first chunk"
          echo "üì¶ Processing chunk: $chunk_file"
          
          # –°–æ–∑–¥–∞–µ–º JSON –¥–ª—è —á–∞–Ω–∫–∞ —Å –¥–µ—Ç–∞–ª—å–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
          echo "üìù Reading files from chunk..."
          TEMP_FILE=$(mktemp)
          CHUNK_PROMPTS=()
          
          while IFS= read -r file; do
              echo "   üìÑ Checking file: $file"
              if [ ! -f "$file" ]; then
                  echo "   ‚ö†Ô∏è File not found: $file"
                  continue
              fi
          
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞
              FILE_SIZE=$(stat -c%s "$file" 2>/dev/null)
              echo "   üìè File size: ${FILE_SIZE} bytes"
          
              if ! jq empty "$file" 2>/dev/null; then
                  echo "   ‚ùå Invalid JSON: $file"
                  continue
              fi
          
              CHUNK_PROMPTS+=("$file")
              echo "   ‚úÖ Valid JSON: $file"
          done < "$chunk_file"
          
          if [ ${#CHUNK_PROMPTS[@]} -eq 0 ]; then
              echo "‚ùå No valid files in chunk"
              exit 1
          fi
          
          echo "üìä Processing ${#CHUNK_PROMPTS[@]} valid files"
          
          # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Ñ–∞–π–ª—ã —á–∞–Ω–∫–∞
          printf '%s\n' "${CHUNK_PROMPTS[@]}" | xargs cat | jq -s '.' > "$TEMP_FILE"
          
          if ! jq empty "$TEMP_FILE" 2>/dev/null; then
              echo "‚ùå Failed to create valid JSON for chunk"
              rm -f "$TEMP_FILE"
              exit 1
          fi
          
          CHUNK_COUNT=$(jq 'length' "$TEMP_FILE")
          TEMP_SIZE=$(stat -c%s "$TEMP_FILE" 2>/dev/null)
          echo "‚úÖ Chunk JSON created: $CHUNK_COUNT prompts, ${TEMP_SIZE} bytes"
          
          # –°–æ–∑–¥–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π payload –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
          PAYLOAD_FILE=$(mktemp)
          jq -n --argjson prompts "$(cat "$TEMP_FILE")" \
                --arg source "github-action-diagnostic" \
                --arg chunk "$chunk_file" \
                '{prompts: $prompts, source: $source, chunk: $chunk}' > "$PAYLOAD_FILE"
          
          PAYLOAD_SIZE=$(stat -c%s "$PAYLOAD_FILE" 2>/dev/null)
          echo "üì¶ Payload created: ${PAYLOAD_SIZE} bytes"
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å API
          echo "üåê Testing API connectivity..."
          PING_STATUS=$(curl -s -w "%{http_code}" -o /dev/null \
            --connect-timeout 10 \
            --max-time 15 \
            -X GET "${{ secrets.SYNC_WEBHOOK_URL }}" 2>/dev/null || echo "000")
          
          echo "üì° API ping result: HTTP $PING_STATUS"
          
          # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–æ–π
          echo "üöÄ Sending diagnostic request..."
          RESPONSE_FILE=$(mktemp)
          ERROR_FILE=$(mktemp)
          
          echo "   üîß cURL command details:"
          echo "   - Method: POST"
          echo "   - URL: [REDACTED]"
          echo "   - Content-Type: application/json"  
          echo "   - API Key: [REDACTED] (${#{{ secrets.SYNC_API_KEY }}} chars)"
          echo "   - Payload size: ${PAYLOAD_SIZE} bytes"
          echo "   - Timeout: 30 seconds"
          
          HTTP_STATUS=$(curl -v -s -w "%{http_code}" \
            -o "$RESPONSE_FILE" \
            -X POST "${{ secrets.SYNC_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -H "X-API-Key: ${{ secrets.SYNC_API_KEY }}" \
            -d @"$PAYLOAD_FILE" \
            --connect-timeout 10 \
            --max-time 30 \
            --retry 0 \
            2>"$ERROR_FILE")
          
          echo "üìä HTTP Status: '$HTTP_STATUS'"
          echo "üì§ Request completed"
          
          # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
          echo "üîç Response analysis:"
          if [ -s "$RESPONSE_FILE" ]; then
              RESPONSE_SIZE=$(stat -c%s "$RESPONSE_FILE" 2>/dev/null)
              echo "   üìÑ Response size: ${RESPONSE_SIZE} bytes"
              echo "   üìÑ Response content (first 500 chars):"
              head -c 500 "$RESPONSE_FILE"
              echo ""
          else
              echo "   ‚ö†Ô∏è No response body received"
          fi
          
          if [ -s "$ERROR_FILE" ]; then
              echo "   üêõ cURL debug info:"
              cat "$ERROR_FILE"
          else
              echo "   ‚ÑπÔ∏è No cURL errors logged"
          fi
          
          # –û—á–∏—Å—Ç–∫–∞ —Ñ–∞–π–ª–æ–≤
          rm -f "$TEMP_FILE" "$PAYLOAD_FILE" "$RESPONSE_FILE" "$ERROR_FILE" files_list.txt chunk_*
          
          # –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞
          echo "üéØ Final status check:"
          if [ -z "$HTTP_STATUS" ]; then
              echo "‚ùå CRITICAL: HTTP_STATUS is empty - network/connection issue"
              exit 1
          elif [ "$HTTP_STATUS" = "000" ]; then
              echo "‚ùå CRITICAL: Could not connect to server - check URL and network"
              exit 1
          elif [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
              echo "‚úÖ SUCCESS: HTTP $HTTP_STATUS - API is working correctly"
              echo "üéâ Diagnostic completed successfully"
          elif [ "$HTTP_STATUS" -ge 400 ] && [ "$HTTP_STATUS" -lt 500 ]; then
              echo "‚ùå CLIENT ERROR: HTTP $HTTP_STATUS"
              echo "   Possible causes:"
              echo "   - Invalid API key"
              echo "   - Wrong request format"
              echo "   - Missing required headers"
              exit 1
          elif [ "$HTTP_STATUS" -ge 500 ]; then
              echo "‚ùå SERVER ERROR: HTTP $HTTP_STATUS"
              echo "   Your API server is experiencing issues"
              exit 1
          else
              echo "‚ùå UNKNOWN ERROR: Unexpected HTTP status '$HTTP_STATUS'"
              exit 1
          fi
          
          echo "üü¢ Diagnostic completed at $(date)"
