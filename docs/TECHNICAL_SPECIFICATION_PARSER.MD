Конечно. Я объединю все предыдущие анализы и уточнения в одно исчерпывающее техническое задание. Этот документ будет содержать все необходимые детали для реализации компонента, включая подробное описание алгоритма и стратегию тестирования.

---

## **Техническое Задание: Компонент `ForumPromptParser`**

### **1. Название компонента**
`ForumPromptParser`

### **2. Назначение**
Компонент предназначен для интеллектуального парсинга HTML-страниц форума с целью извлечения, классификации и структурирования данных о промптах для ИИ. Основная задача — надежно обрабатывать разнородную и неконсистентную структуру постов, автоматически применяя соответствующую логику для извлечения информации.

Итоговые данные должны быть преобразованы в коллекцию объектов, соответствующих JSON-структуре `PromptData`, и быть готовыми для сохранения в базу данных или отображения в пользовательском интерфейсе.

### **3. Функциональные требования**
3.1. **Входные данные:** Компонент должен принимать на вход HTML-содержимое страницы в виде единой строки (`String`).
3.2. **Сегментация:** Должен производить разделение HTML на отдельные посты, используя CSS-селектор `table.ipbtable[data-post]`.
3.3. **Извлечение метаданных:** Для каждого поста должны извлекаться базовые метаданные: ID поста (`data-post`), автор (`span.normalname a`), дата создания (из заголовка поста) и дата последнего изменения (`span.edit`, имеет приоритет).
3.4. **Классификация постов:** Компонент должен реализовывать алгоритм классификации для определения типа содержимого каждого поста. Минимальный набор типов для распознавания:
- `META_PROMPT`: Сложные фреймворки-инструкции (например, LCMRT, LCM9).
- `EXTERNAL_RESOURCE`: Посты со ссылками на внешние ресурсы (GitHub, Hugging Face).
- `STANDARD_PROMPT`: Посты, оформленные по стандартному шаблону (`ПРОМПТ № XXX`).
- `JAILBREAK`: Промпты для обхода ограничений ИИ.
- `TEMPLATE_PROMPT`: Промпты-шаблоны с плейсхолдерами для заполнения.
- `FILE_ATTACHMENT`: Посты, где основной контент находится в прикрепленном `.txt` файле.
- `DISCUSSION`: Нерелевантные посты (вопросы, обсуждения), которые должны быть отфильтрованы.
3.5. **Стратегии извлечения:** В зависимости от типа поста, должна применяться соответствующая стратегия парсинга контента, описания и вариантов.
3.6. **Обработка вложений:** Компонент должен обнаруживать прикрепленные файлы (`<a class="ipb-attach attach-file">`).
- Если прикреплен `.txt` файл, его содержимое **приоритетно** используется как основной текст промпта. Текст из тела самого поста становится описанием.
- Информация о других файлах (`.zip` и т.д.) сохраняется в метаданных, но их содержимое не обрабатывается.
3.7. **Формирование результата:** Результат парсинга должен быть преобразован в `List<PromptData>`.
- Поле `type` в структуре `prompt_variants` по умолчанию должно иметь значение `"prompt"`.

### **4. Нефункциональные требования**
4.1. **Производительность:** Обработка страницы должна выполняться асинхронно в фоновом потоке (`Dispatchers.IO`), не блокируя UI-поток.
4.2. **Надежность:** Ошибки при парсинге одного поста не должны прерывать обработку остальных. Проблемные посты должны логироваться с указанием `post_id`.
4.3. **Расширяемость:** Архитектура должна позволять легко добавлять новые `PostType` и соответствующие им `ParsingStrategy` без модификации основного кода компонента.
4.4. **Зависимости:** Jsoup (для парсинга HTML), kotlinx.coroutines (для асинхронности), kotlinx.serialization (для сериализации), Ktor Client (для скачивания файлов по URL).

### **5. Архитектура и структура кода**
Компонент будет реализован с использованием принципов SOLID и KISS. Основные классы и интерфейсы будут сгруппированы в пакете `com.example.promptparser`.

-   **`PromptData.kt`**: `@Serializable data class`, точно соответствующий предоставленной JSON-структуре. Включает вложенные классы для всех вложенных объектов.
-   **`PostType.kt`**: `enum class` со всеми типами постов (`META_PROMPT`, `EXTERNAL_RESOURCE` и т.д.).
-   **`ParsingStrategy.kt`**: `sealed interface ParsingStrategy` с единым методом `suspend fun parse(postElement: Element): PromptData?`. Каждая реализация этого интерфейса будет отвечать за парсинг одного типа поста.
-   **`PostClassifier.kt`**: Класс, отвечающий за определение `PostType` элемента поста на основе набора эвристик.
-   **`ForumPromptParser.kt`**: Основной класс, управляющий всем процессом.

### **6. Детальная реализация "Умного Алгоритма"**
Ниже приведено пошаговое описание логики, которую должен реализовать разработчик.

#### **Шаг 1. Точка входа: метод `parse`**
Эта функция оркестрирует весь процесс.
1.  Принимает на вход `htmlContent: String`.
2.  Парсит HTML в DOM-дерево с помощью `Jsoup.parse()`.
3.  Находит все элементы постов через `dom.select("table.ipbtable[data-post]")`.
4.  Используя `coroutineScope`, запускает асинхронную обработку каждого элемента поста в отдельной корутине (`async`).
5.  Собирает результаты всех задач через `awaitAll()`, отфильтровывает `null` значения (нерелевантные посты) и возвращает итоговый `List<PromptData>`.

#### **Шаг 2. Обработка одного поста (`processPost`)**
1.  **Извлечение метаданных:** Получить `author`, `post_id`, `created_at`, `updated_at`. Даты парсить и преобразовывать в формат ISO 8601 (`yyyy-MM-dd'T'HH:mm:ss.SSS'Z'`).
2.  **Классификация поста:** Передать `postElement` в `PostClassifier`. Классификатор должен последовательно (в порядке приоритета) применять правила:
    -   Есть ли прикрепленный `.txt` файл? → `PostType.FILE_ATTACHMENT`.
    -   Есть ли ссылки на GitHub/HuggingFace и прикреплен `.zip`? → `PostType.EXTERNAL_RESOURCE`.
    -   Есть ли ключевые слова "LCMRT", "LCM9", "фреймворк"? → `PostType.META_PROMPT`.
    -   Есть ли `<span>` с текстом `ПРОМТ №`? → `PostType.STANDARD_PROMPT`.
    -   Есть ли ключевые слова "обход цензуры", "developer mode"? → `PostType.JAILBREAK`.
    -   Есть ли плейсхолдеры `{...}` или `[...]` в тексте? → `PostType.TEMPLATE_PROMPT`.
    -   Есть ли цитаты или явные вопросы без маркеров промпта? → `PostType.DISCUSSION`.
3.  **Выбор и выполнение стратегии:** На основе `PostType` выбрать из `Map<PostType, ParsingStrategy>` нужную реализацию и вызвать ее метод `parse(postElement)`.

#### **Шаг 3. Реализация ключевых стратегий (`ParsingStrategy`)**
-   **`FileAttachmentStrategy`**: Находит ссылку на `.txt` файл, асинхронно скачивает его содержимое, которое становится `content`. Текст из тела поста становится `description`.
-   **`MetaPromptStrategy`**: Ищет спойлеры с ключевыми словами "Промт", "Инструкция", "Код" для `content`. Остальные спойлеры объединяются в `description`.
-   **`StandardPromptStrategy`**: Парсит посты формата "ПРОМТ № XXX", извлекая `title` и разделяя `description` и `content` по ключевым словам "Подсказка", "Пример" и языковым маркерам.
-   **`DiscussionStrategy`**: Всегда возвращает `null` для последующей фильтрации.

#### **Шаг 4. Финальное формирование `PromptData`**
1.  Создать `UUID.randomUUID().toString()` для поля `id`.
2.  Установить `version` в "1.0.0".
3.  Заполнить метаданные, полученные на Шаге 2.
4.  В `prompt_variants` создать один вариант, установив `type` в `"prompt"` и заполнив `content`.
5.  Извлечь теги из `description` или `title` по ключевым словам.

### **7. Интерфейсы и API**

```kotlin
@Serializable
data class PromptData( /* ... все поля согласно JSON ... */ )

interface IForumPromptParser {
    /**
     * @param htmlContent HTML-контент страницы.
     * @return Список готовых объектов PromptData.
     * @throws HtmlParsingException при ошибке парсинга.
     */
    suspend fun parse(htmlContent: String): List<PromptData>
}
```

### **8. Обработка ошибок**
-   **`HtmlParsingException`**: Выбрасывается при невозможности распарсить входной HTML.
-   **`FileDownloadException`**: Выбрасывается при ошибке скачивания вложения.
-   **Логирование:** Ошибки обработки отдельных постов логируются с `post_id` без прерывания общего процесса. Посты с неполными критическими данными (title, content) отбрасываются.

### **9. Стратегия тестирования**
Для обеспечения надежности компонента необходимо реализовать многоуровневую стратегию тестирования.

#### **9.1. Модульное тестирование (Unit Testing)**
**Цель:** Проверить каждый компонент в изоляции.
**Инструменты:** JUnit 5, MockK, AssertJ/Strikt.

-   **`PostClassifier`**: Создать тестовые наборы с HTML-фрагментами для каждого `PostType` и проверить корректность определения типа.
-   **Каждая `ParsingStrategy`**:
    -   "Happy path": Подать идеально отформатированный HTML и проверить, что все поля `PromptData` заполнены верно.
    -   "Sad path": Подать HTML с отсутствующими элементами и убедиться, что метод возвращает `null`.
    -   `FileAttachmentStrategy` тестировать с использованием мока HTTP-клиента (`Ktor MockEngine`) для имитации успешного скачивания и ошибок сети.

#### **9.2. Интеграционное тестирование (Integration Testing)**
**Цель:** Проверить взаимодействие между `ForumPromptParser`, `PostClassifier` и `ParsingStrategy`.

-   Подать на вход `ForumPromptParser` HTML-фрагмент, содержащий один пост, и убедиться, что вызывается верная стратегия и пост успешно парсится.

#### **9.3. Сквозное тестирование (End-to-End Testing)**
**Цель:** Проверить работу компонента на реальных данных от начала до конца.

1.  **Тестовые данные:** Сохранить предоставленные HTML-фрагменты в `src/test/resources/html_samples/`.
2.  **Эталонные результаты:** Для каждого HTML-файла создать соответствующий `..._expected.json` файл с эталонным JSON-массивом `PromptData`.
3.  **Написание теста:** Тест должен циклически:
    -   Читать HTML-файл.
    -   Вызывать `ForumPromptParser.parse()`.
    -   Читать и десериализовать эталонный JSON.
    -   Сравнивать полученный результат с эталонным.

### **10. Пример использования**

```kotlin
import kotlinx.coroutines.runBlocking

suspend fun main() {
    // 1. Инициализация парсера с реальными зависимостями
    val parser: IForumPromptParser = createForumPromptParser() // DI-функция

    // 2. Загрузка HTML
    val htmlContent = loadHtmlFromFile("path/to/forum_page.html")

    // 3. Асинхронный запуск
    runBlocking {
        val prompts = parser.parse(htmlContent)

        // 4. Дальнейшая обработка: сохранение в БД, логирование и т.д.
        savePromptsToDatabase(prompts)
        println("Извлечено и сохранено ${prompts.size} промптов.")
    }
}
```