Конечно. Основываясь на нашем всестороннем обсуждении и анализе существующего Python-приложения, я подготовил подробное техническое задание (ТЗ) на разработку нового десктопного приложения на Compose Multiplatform.

Это ТЗ описывает не просто MVP, а полнофункциональный продукт, который не только повторяет, но и значительно расширяет возможности исходного приложения.

---

## 1. Введение

### 1.1. Назначение и цели проекта

Данное ТЗ описывает требования к разработке полнофункционального кросс-платформенного десктопного приложения "AI Prompt Master" с использованием фреймворка Compose Multiplatform (KMP).

**Основная цель** — создать единое, высокопроизводительное и удобное приложение для управления, редактирования, улучшения и использования AI-промптов, которое заменит и превзойдет по функциональности существующее решение на Python/PyQt6.

Приложение должно предоставлять централизованную среду для работы с промптами, интегрироваться с локальными и удаленными LLM, а также включать инструменты для автоматизации сбора и обработки данных.

### 1.2. Ключевые бизнес-цели

*   **Повышение производительности пользователя:** Ускорить и упростить цикл работы с промптами.
*   **Улучшение качества промптов:** Предоставить инструменты для автоматического улучшения и версионирования.
*   **Расширение функциональности:** Добавить новые возможности, такие как интегрированный AI-чат и продвинутый парсинг.
*   **Обеспечение качества:** Создать стабильный, поддерживаемый и масштабируемый продукт на современном технологическом стеке.

## 2. Функциональные требования

### FR1: Управление промптами (CRUD и расширенные операции)

*   **FR1.1: Отображение промптов:**
    *   **FR1.1.1:** Реализовать главный экран с отображением списка промптов.
    *   **FR1.1.2:** Обеспечить производительную "бесконечную" прокрутку (пагинацию) для работы с большим количеством записей (10 000+).
    *   **FR1.1.3:** Реализовать многофункциональный поиск в реальном времени по названию, описанию, содержимому и тегам.
    *   **FR1.1.4:** Реализовать систему фильтрации по категории, статусу (включая "избранное") и тегам.
    *   **FR1.1.5:** Реализовать систему сортировки по дате, названию, категории и статусу "избранного".
*   **FR1.2: Создание/Редактирование промптов:**
    *   **FR1.2.1:** Реализовать экран/диалог для создания и редактирования всех полей промпта, включая: название, описание, контент (RU/EN), категорию, теги, статус, версию, метаданные (автор, источник) и т.д.
    *   **FR1.2.2:** Обеспечить удобный редактор для переменных внутри промпта (создание, редактирование, удаление, автоопределение).
    *   **FR1.2.3:** Реализовать функцию "умного улучшения промпта": пользователь вводит черновой вариант, нажимает кнопку, и приложение отправляет его на обработку к LLM по специальному системному промпту для получения улучшенной, структурированной версии.
*   **FR1.3: Просмотр промпта:**
    *   **FR1.3.1:** Реализовать отдельный экран или детальную панель для просмотра всей информации о выбранном промпте в удобном, отформатированном виде.
    *   **FR1.3.2:** Обеспечить подсветку синтаксиса (Markdown) и переменных в теле промпта.
*   **FR1.4: Удаление промптов:** Реализовать функцию удаления одного или нескольких выбранных промптов с диалогом подтверждения.

### FR2: Интеграция с Git

*   **FR2.1:** При сохранении изменений (создание/редактирование) промпта, приложение должно не только сохранять данные в локальную БД, но и автоматически генерировать/обновлять соответствующий JSON-файл в локальном Git-репозитории.
*   **FR2.2:** После сохранения файла приложение должно автоматически выполнять `git add` и `git commit` с осмысленным сообщением (например, "feat(prompts): Update prompt 'Example Prompt'").
*   **FR2.3 (Опционально, v2):** Реализовать автоматический `git push` в удаленный репозиторий. Настройки Git (путь к репозиторию, данные для аутентификации) должны храниться локально.

### FR3: Продвинутый парсинг и импорт

*   **FR3.1: Парсер веб-страниц (Selenium):**
    *   **FR3.1.1:** Реализовать модуль, использующий Selenium на Kotlin, для автоматического открытия веб-страниц, выполнения JavaScript и скачивания итогового HTML-кода.
    *   **FR3.1.2:** Логика должна быть настраиваемой (URL, селекторы для ожидания) для адаптации к разным сайтам.
*   **FR3.2: "Умный" импортер (Jsoup):**
    *   **FR3.2.1:** Реализовать модуль на базе Jsoup для парсинга скачанных HTML-файлов.
    *   **FR3.2.2:** Импортер должен эвристически определять и извлекать ключевые данные: заголовок, автора, контент, дату, вложения.
    *   **FR3.2.3:** Реализовать интерактивный UI для валидации: после парсинга приложение должно показывать извлеченные данные пользователю для подтверждения или ручной корректировки перед сохранением в БД.

### FR4: Интегрированный AI-чат

*   **FR4.1:** Реализовать отдельный экран "AI Чат".
*   **FR4.2:** Обеспечить возможность выбора LLM-провайдера из списка (например, OpenRouter, Gemini).
*   **FR4.3:** Реализовать безопасное локальное хранение API-ключей для разных провайдеров (с использованием шифрования).
*   **FR4.4:** Интерфейс чата должен поддерживать историю диалога, отображение сообщений от пользователя и ассистента, а также индикацию процесса генерации ответа.
*   **FR4.5:** Реализовать возможность легко вставить выбранный промпт из библиотеки в окно чата.

## 3. Нефункциональные требования

*   **NFR1: Производительность:**
    *   **NFR1.1:** Время холодного старта приложения (после импорта) — не более 3 секунд.
    *   **NFR1.2:** Отклик на поиск/фильтрацию в UI — не более 300 мс на 10 000 записей.
    *   **NFR1.3:** Прокрутка списков должна быть плавной (целевой показатель 60 FPS).
*   **NFR2: Архитектура и качество кода:**
    *   **NFR2.1:** Строгое следование принципам многослойной архитектуры (Clean Architecture): Data, Domain, Presentation.
    *   **NFR2.2:** Использование Decompose для навигации и управления жизненным циклом компонентов.
    *   **NFR2.3:** Использование Koin для внедрения зависимостей.
    *   **NFR2.4:** Весь асинхронный код должен быть реализован с использованием Kotlin Coroutines и Flow.
*   **NFR3: Пользовательский интерфейс (UI/UX):**
    *   **NFR3.1:** UI должен быть реализован на Compose Multiplatform с использованием компонентов и гайдлайнов Material 3.
    *   **NFR3.2:** Приложение должно иметь адаптивный дизайн, корректно отображающийся на экранах разного размера (однопанельный режим на узких окнах, двухпанельный на широких).
    *   **NFR3.3:** Поддержка светлой и темной тем оформления.
*   **NFR4: Надежность и обработка ошибок:**
    *   **NFR4.1:** Приложение должно корректно обрабатывать ошибки сети, доступа к файлам, ошибки API LLM и показывать пользователю осмысленные сообщения об ошибках.
    *   **NFR4.2:** Использовать структурированную систему ошибок (`DomainError`, `StringHolder`) для разделения бизнес-ошибок и технических исключений.

## 4. Ограничения и допущения

*   **Ограничения:**
    *   **Платформы:** Windows, macOS, Linux.
    *   **Технологический стек:** Kotlin, Compose Multiplatform, Room, Ktor, Decompose, Koin, Jsoup, Selenium.
    *   **Среда выполнения:** Требуется установленная JVM 17+.
*   **Допущения:**
    *   Пользователь имеет базовые навыки работы с Git, если планирует использовать функции интеграции.
    *   Для работы с удаленными LLM и Git требуется активное интернет-соединение.

## 5. Интерфейсы и интеграции

*   **5.1: Локальная файловая система:** Чтение/запись JSON-файлов промптов, HTML-файлов для парсинга.
*   **5.2: Git:** Взаимодействие с локальным репозиторием Git через командную строку или Java-библиотеку (например, JGit).
*   **5.3: Внешние API (LLM):** Взаимодействие по REST API с сервисами OpenRouter, Google AI (Gemini) и другими OpenAI-совместимыми API.

## 6. Метрики приёмки

*   **AC1: Паритет функциональности:** Вся основная функциональность Python-приложения (просмотр, поиск, фильтры, редактирование) реализована и работает корректно.
*   **AC2: Успешный импорт:** Приложение успешно парсит тестовую HTML-страницу и предлагает пользователю корректно распознанные данные для сохранения.
*   **AC3: Работоспособность Git-интеграции:** Изменение промпта в UI приводит к автоматическому созданию коммита в локальном репозитории.
*   **AC4: Работоспособность AI-чата:** Пользователь может ввести API-ключ, выбрать модель и успешно провести диалог с LLM через интерфейс приложения.
*   **AC5: Соответствие NFR:** Приложение проходит тесты производительности и соответствует требованиям к архитектуре и UI/UX, описанным в разделе 3.

### Идеи по улучшению проекта

#### Категория 1: Улучшение пользовательского опыта (UX)

1.  **Полнотекстовый поиск (FTS5):**
    *   **Проблема:** Стандартный `LIKE '%query%'` может быть медленным на очень больших текстах.
    *   **Идея:** Использовать виртуальную таблицу **FTS5** в SQLite. Это встроенный механизм полнотекстового поиска, который работает на порядки быстрее и поддерживает более сложные запросы (например, поиск по точным фразам, ранжирование результатов по релевантности). Это относительно легко интегрируется с Room.

2.  **Продвинутый редактор промптов:**
    *   **Идея:** Вместо простого `TextField` использовать полноценный редактор кода с подсветкой синтаксиса Markdown, нумерацией строк и автодополнением для переменных (`[` -> выпадающий список). Для этого можно использовать готовые KMP-библиотеки редакторов кода.

3.  **Система шаблонов и версионирования промптов:**
    *   **Идея:** Позволить пользователю сохранять не просто один промпт, а создавать **шаблоны** с разными версиями. Например, пользователь мог бы легко переключаться между "v1.0 - краткий" и "v1.1 - подробный с примерами" для одного и того же промпта. Это можно реализовать, добавив в БД связь "один-ко-многим" для промптов.

4.  **Горячие клавиши (Hotkeys):**
    *   **Идея:** Добавить поддержку горячих клавиш для всех основных действий: новый промпт (`Ctrl+N`), сохранить (`Ctrl+S`), поиск (`Ctrl+F`), переключение между экранами. Это значительно ускорит работу профессиональных пользователей. Compose for Desktop имеет встроенные API для этого.

#### Категория 2: Интеллектуальные и AI-функции

5.  **Автоматическая классификация и тегирование:**
    *   **Проблема:** Ручное добавление категорий и тегов утомительно.
    *   **Идея:** При создании или импорте нового промпта автоматически отправлять его текст в LLM с запросом: "Проанализируй этот промпт и предложи 5 релевантных тегов и наиболее подходящую категорию". Предложенные теги можно показать пользователю для подтверждения.

6.  **"A/B тестирование" промптов:**
    *   **Идея:** Создать интерфейс, где пользователь может ввести один и тот же запрос, но запустить его с двумя (или более) разными версиями промпта одновременно. Результаты от LLM будут показаны рядом, что позволит пользователю наглядно сравнить, какой промпт работает лучше.

7.  **Динамическое "встраивание" контекста в чат (RAG - Retrieval-Augmented Generation):**
    *   **Идея:** Перед отправкой запроса пользователя в AI-чат, приложение могло бы автоматически найти 2-3 наиболее релевантных промпта из вашей библиотеки (используя поиск по ключевым словам) и незаметно добавить их в контекст запроса к LLM. Это могло бы значительно повысить качество и релевантность ответов чата, так как он будет "знать" о ваших лучших практиках.

#### Категория 3: Архитектурные и технические улучшения

8.  **Плагинная архитектура:**
    *   **Идея:** Сделать систему LLM-провайдеров и парсеров расширяемой. Вместо того чтобы жестко кодировать поддержку Gemini или OpenRouter, можно создать общие интерфейсы (`ILlmProvider`, `IWebParser`) и позволить в будущем легко добавлять новые реализации (для Claude, Mistral и т.д.) как отдельные модули-плагины.

9.  **Синхронизация между устройствами:**
    *   **Идея:** Для тех, кто работает на нескольких компьютерах, можно добавить функцию синхронизации локальной БД через облачный сервис (например, используя бесплатный уровень Firebase Firestore или просто синхронизируя файл БД через Dropbox/Google Drive).

10. **Кросс-платформенность на мобильных устройствах:**
    *   **Идея:** Раз уж мы используем Compose Multiplatform, самым логичным шагом в будущем станет добавление **Android-модуля** в проект. Большая часть вашего кода (`commonMain`) будет переиспользована. Вам нужно будет только написать UI, адаптированный под мобильные экраны. Это превратит ваше приложение в по-настоящему универсальный инструмент.

---

Эти идеи можно рассматривать как дорожную карту (roadmap) после завершения основного ТЗ. Они показывают, что у проекта есть огромный потенциал для роста, и выбранный вами стек технологий позволяет реализовать любую из этих идей.