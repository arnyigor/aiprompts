## **Техническое Задание: Модуль "Интерактивный Ассистент Импорта" (v2.0)**

### 1. Введение

#### 1.1. Назначение и цели

Данное ТЗ описывает требования к разработке интерактивного модуля (экрана) "Ассистент Импорта" в составе десктопного приложения "AI Prompt Master".

**Основная цель модуля** — предоставить пользователю высокоэффективный, полуавтоматический инструмент для точного и быстрого преобразования "сырых" HTML-данных (постов с форума) в структурированные JSON-файлы промптов.

Модуль должен минимизировать рутинные операции (сбор метаданных, копирование текста), предоставляя при этом пользователю полный контроль над финальной структурой и содержанием данных, а также интеллектуальные подсказки для ускорения рабочего процесса.

### 2. Функциональные требования

#### FR1: Загрузка и предварительная обработка данных

*   **FR1.1: Выбор файлов:** Пользователь должен иметь возможность выбрать один или несколько локальных HTML-файлов для импорта через системный диалог выбора файлов.
*   **FR1.2: Первичный парсинг:**
    *   **FR1.2.1:** После выбора файлов приложение должно запустить **`SimpleParser`** для каждого из них.
    *   **FR1.2.2:** Парсер должен извлекать из HTML список "сырых" постов, соответствующих модели `RawPostData`. Каждый объект `RawPostData` должен содержать: `postId`, `author`, `date`, `fullHtmlContent`, флаг `isLikelyPrompt` и `fileAttachmentUrl`.
    *   **FR1.2.3:** Процесс парсинга должен выполняться в фоновом потоке, не блокируя UI. На время парсинга должен отображаться индикатор загрузки.
*   **FR1.3: Приоритетная сортировка:**
    *   Сразу после парсинга и перед отображением, список `RawPostData` должен быть автоматически отсортирован по следующим критериям в порядке убывания приоритета:
        1.  Посты с `.txt` вложением.
        2.  Посты, помеченные флагом `isLikelyPrompt`.
        3.  По убыванию длины `fullHtmlContent`.

#### FR2: Основной интерфейс (Трехпанельный макет)

*   **FR2.1: Панель навигации по постам (левая):**
    *   **FR2.1.1:** Отображать вертикальный, отсортированный список всех извлеченных `RawPostData`.
    *   **FR2.1.2:** Каждый элемент списка должен содержать: имя автора, ID поста и дату.
    *   **FR2.1.3:** **Визуальная подсказка:** Элементы с флагом `isLikelyPrompt = true` должны быть визуально выделены (например, иконкой ✨ или цветом фона).
    *   **FR2.1.4:** **Индикация статуса:** Каждый элемент должен иметь визуальный индикатор своего статуса:
        *   "Необработанный" (по умолчанию).
        *   "Готов к импорту" (когда пользователь заполнил обязательные поля `title` и `content` для этого поста).
        *   "Пропущен" (когда пользователь явно пометил пост как нерелевантный).
    *   **FR2.1.5:** **Фильтрация списка:** Пользователь должен иметь возможность фильтровать список по статусу ("Все", "Вероятные промпты", "Готовые", "Необработанные").
*   **FR2.2: Панель просмотра и редактирования (центральная):**
    *   **FR2.2.1:** При выборе поста в левой панели, в этой панели должна отображаться детальная информация.
    *   **FR2.2.2:** **Интерактивный предпросмотр:** Должен быть реализован компонент (например, на базе WebView), отображающий `fullHtmlContent` выбранного поста в его оригинальном HTML-форматировании.
    *   **FR2.2.3:** **Механизм "умного" выделения:**
        *   Пользователь должен иметь возможность выделить текст внутри компонента предпросмотра.
        *   После выделения должны появляться контекстные кнопки (например, "Назначить как Контент", "Назначить как Описание").
        *   При нажатии на кнопку выделенный текст (очищенный от HTML-тегов) должен автоматически вставляться в соответствующее поле редактирования.
    *   **FR2.2.4:** **Поля редактирования:** Должны присутствовать редактируемые поля для финального `PromptData`: "Заголовок", "Описание", "Контент", "Категория", "Теги".
    *   **FR2.2.5:** **Кнопки управления постом:** Должны быть кнопки **"Сохранить и перейти к следующему необработанному"** и **"Пропустить этот пост"**.
    *   **FR2.2.6: Сохранение состояния редактирования:** При переключении между постами в левом списке, все изменения в полях редактирования (`title`, `description` и т.д.) для предыдущего поста должны **автоматически сохраняться** в состоянии компонента. При возврате к этому посту, все отредактированные данные должны быть восстановлены.
*   **FR2.3: Панель итогов и действий (правая):**
    *   **FR2.3.1:** Отображать сводную статистику: "Готово к импорту: X", "Пропущено: Y", "Осталось: Z".
    *   **FR2.3.2:** Содержать кнопку "Сгенерировать JSON-файлы", которая становится активной только при наличии хотя бы одного поста со статусом "Готов к импорту".

#### FR3: Генерация и сохранение результатов

*   **FR3.1:** При нажатии на кнопку "Сгенерировать JSON-файлы", приложение должно:
    *   **FR3.1.1:** Собрать все посты со статусом "Готов к импорту".
    *   **FR3.1.2:** Для каждого такого поста сформировать объект `PromptJson` на основе **сохраненных отредактированных данных** для этого поста.
    *   **FR3.1.3:** Сохранить каждый `PromptJson` в отдельный `.json` файл в указанную пользователем директорию. Имя файла должно формироваться на основе UUID, сгенерированного для промпта.
    *   **FR3.1.4:** По завершении процесса показать пользователю уведомление об успешном сохранении и количестве созданных файлов.

### 3. Нефункциональные требования

*   **NFR1: Производительность:**
    *   **NFR1.1:** UI должен оставаться отзывчивым при работе со списком до 500 постов.
    *   **NFR1.2:** Вставка выделенного текста в поля редактирования должна происходить мгновенно.
*   **NFR2: Пользовательский интерфейс (UI/UX):**
    *   **NFR2.1:** Интерфейс должен быть интуитивно понятным и требовать минимального количества кликов для выполнения основной задачи (обработки поста).
    *   **NFR2.2:** Все интерактивные элементы должны иметь четкую обратную связь (подсветка при наведении, индикация выбранного элемента).
*   **NFR3: Надежность:**
    *   **NFR3.1:** Ошибки при парсинге одного файла не должны прерывать обработку остальных.

### 4. Архитектура и структура кода

*   **`ImporterComponent` (Decompose):**
    *   Будет управлять состоянием всего экрана (`ImporterState`).
    *   Содержать всю бизнес-логику: вызов парсера, обработку действий пользователя (клики, выделение, редактирование), вызов UseCase для сохранения файлов.
*   **`ImporterState` (Kotlin Data Class):**
    *   Единый класс состояния, содержащий списки постов, статусы и **`Map` для хранения отредактированных данных** для каждого поста.
*   **`SimpleParser` (JVM):**
    *   Реализация парсера, как было спроектировано ранее.
*   **`ParseRawPostsUseCase` и `SavePromptsAsFilesUseCase` (commonMain):**
    *   UseCases, которые будут вызываться из `ImporterComponent`.

### 5. Стратегия тестирования

*   **Модульное тестирование (Unit Testing):**
    *   `SimpleParser` должен быть покрыт тестами, проверяющими корректное извлечение `RawPostData` из различных HTML-семплов.
    *   `ImporterComponent` должен быть протестирован на логику: как меняется `state` (включая `editedData`) в ответ на различные события.
*   **UI-тестирование (Compose):**
    *   Проверить, что UI корректно отображает разные состояния.
    *   Проверить, что кнопки и поля ввода правильно вызывают методы компонента.